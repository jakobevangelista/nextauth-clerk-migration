# Migration Guide: Moving from Next-Auth to Clerk 

## Introduction

Migrating from Next-Auth to Clerk can be daunting, but this guide aims to help you achieve a seamless transition with zero downtime. This guide covers running both middlewares simultaneously, importing users while keeping your application active, and ensuring a smooth experience for your users.

## Prerequisites

Before you begin, ensure you have the following:

- An active Clerk account.
- Your current application using Next-Auth.
- Access to your user database.

## Migration Overview

To ensure a smooth migration with minimal disruption to your users, we will follow these steps:
1. [**Install @clerk/nextjs and p-retry**](#1-install-clerknextjs-and-p-retry)
2. [**Add Clerk Middleware**](#2-add-clerk-middleware)
3. [**Add Clerk provider**](#3-wrap-application-in-clerkprovider-and-migrationlayout-and-queryclient)
4. [**Clone the _auth-migration folder**](#4-clone-the-srcapp_auth-migration-folder)
5. [**Implement trickle migration**](#5-trickle-migration)
6. [**Switch Data Access Patterns to Clerk**](#6-migrate-data-access-patterns-srcapppagetsx)
7. [**Implement Batch Import**](#7-batch-import)
8. [**Implement Sign-up and Sign-in with Clerk**](#8-sign-ups-and-sign-ins-go-through-the-clerk-components)

During migration, there are going to be 2 major states for your app, we label them as "during the migration" and "after the migration".

## Migration Steps

## During the migration ('migrating' Branch)

During this part of the migratiion, users will sign in and sign up through nextauth.

### 1. Install @clerk/nextjs and p-retry

(I dont know how to do the cool tabbed thing to install in npm, yarn, pnpm, bun but once I learn how to do it, imma do it)

Install @clerk/nextjs and p-retry. P-retry is allows us to implement exponential backoff functions for promises, this package is used in &lt;TrickleWrapper>.

```bash
npm install @clerk/nextjs p-retry
```
```bash
yarn add @clerk/nextjs p-retry
```
```bash
pnpm add @clerk/nextjs p-retry
```
```bash
bun add @clerk/nextjs p-retry
```

### 2. Add Clerk Middleware

We need Clerk's middleware in order to use useSignIn within &lt;TrickleWrapper>.

First, add the Clerk middleware alongside the existing NextAuth middleware. Clerk middleware has to be the top wrapper for the entire middleware. In the example provided, we put a sample middleware functions within the next auth middleware, you can add whatever custom middleware functions you have.

```js
// src/app/middleware.ts

import NextAuth from "next-auth";
import authConfig from "@/auth.config";
import { clerkMiddleware } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";

const { auth } = NextAuth(authConfig);
const nextAuthMiddle = auth(function middleware(req) {
  // custom middleware functions here
});

export default clerkMiddleware(async (clerkauth, req) => {
  await nextAuthMiddle(req); // works but needs AppRouteHandlerFnContext
  return NextResponse.next();
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

### 3. Wrap Application in &lt;ClerkProvider>

Wrap your application layout in the &lt;ClerkProvider> component to enable Clerk authentication. 

(Highlight the lines of the wrapper)

```js 
// src/app/layout.tsx
import { ClerkProvider, SignedIn, UserButton } from "@clerk/nextjs";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body className={inter.className}>
          {children}
        </body>
      </html>
    </ClerkProvider>
  );
}

```

### 4. Clone the "/src/app/_auth-migration" folder

This folder contains all the components needed to do the migrations.

### 5. Trickle Migration

To seamlessly transition your users from NextAuth to Clerk without any downtime, you have to wrap the &lt;TrickleWrapper> around your application in a template.ts file in the root component and export the endpoint that the trickle wrapper calls along with some helper functions the endpoint needs. You can read more about what template.ts does [here](https://nextjs.org/docs/app/api-reference/file-conventions/template). This code will automatically create and sign in users in Clerk who were previously authenticated with NextAuth.

During this process, users will sign in and sign up through next-auth.

(right now the implementation only uses plaintext, future update it to use hashed passwords)

#### Wrapping your application with &lt;TrickleWrapper

We have the wrapper made for you within the _auth-migration folder. You just need to export it, create a template.ts folder inside the root of your app folder, and wrap your app in it.

```js
// src/app/template.tsx

import TrickleWrapper from "./_auth-migration/trickleWrapper";

export default function Tempalate({ children }: { children: React.ReactNode }) {
  return <TrickleWrapper>{children}</TrickleWrapper>;
}
```

#### Create the endpoint and wrapper functions

Next-auth allows you to bring your own db, that means we can't encompass all the possible adapters, but what we can do is have you implement helper functions that feed into our api. We require 2 There are examples in the _auth-migration folder in sampleHelper.ts to see what our createAPI function requires. One function is just the old auth() function from nextauth, we have you implement this because now you can use this function throughout your whole app when you are switching the data access layer from next-auth's auth() to Clerk's auth(). 

The second function uses the createUser function's params, so you can pass whatever options you'd like as an object through this function, we've also exported the type for you. You can find more information about the params [here](https://clerk.com/docs/references/backend/user/create-user)

These are an example of the helper functions, you have to implement them yourself using your adapter. This example uses drizzle ORM with Neon Postgres.
```js
// src/app/_auth-migration/sampleHelpers.ts

"use server";
import { auth } from "@/auth";
import { db } from "@/server/neonDb";
import { users } from "@/server/neonDb/schema";
import { eq } from "drizzle-orm";
import { type CreateUserParams } from "./routeHelper";

// returns true if the old auth system has a session
export async function oldCheckHasSession() {
  const session = await auth();
  return session;
}

// returns data about the user using creatUserParams
export async function oldGetUserData() {
  const session = await auth();
  const user = await db.query.users.findFirst({
    where: eq(users.email, session!.user!.email!),
  });

  return {
    id: user?.id,
    emailAddress: [session!.user!.email!],
    password: user!.password,
    skipPasswordChecks: true,
    skipPasswordRequirement: true,
  } as CreateUserParams;
}

```

In /app/api/auth-migration, copy and paste this code into route.ts. Make sure to use your own helper functions you previously implemented.

```js
// src/app/api/auth-migration/route.ts

import {
  oldCheckHasSession,
  oldGetUserData,
} from "@/app/_auth-migration/sampleHelpers";
import { createMigrationHandler } from "@/app/_auth-migration/routeHelper";

export const POST = createMigrationHandler({
  oldCheckHasSession,
  oldGetUserData,
});
```

### 6. Migrate Data Access Patterns (/src/app/page.tsx)

Update all data access patterns to use Clerk's auth() instead of NextAuth's auth(). While the migration is happening, we will use the external_id (or use the patched auth helper) from Clerk in order to retrieve data.

```diff
- import { auth } from "@/auth";
+ import { auth } from "@clerk/nextjs/server"

-  const session = await auth();
-  if (!session) return <div>Not Signed In</div>;

+ const { userId } : { userId: string | null } = await auth();
+ if (!userId) <div>Not Signed In</div>;

or

+ import { currentUser } from "@clerk/nextjs/server"
+ const user = await currentUser();
+ if(!user) <div>Not Signed In </div>;

```

#### Custom session claims

Our sessions allow for conditional expressions. This would allow you add a session claim that will return either the `externalId` (the previous id for your user) when it exists, or the `userId` from Clerk. This will result in your imported users returning their `externalId` while newer users will return the Clerk `userId`.

In your Dashboard, go to Sessions -> Edit. Add the following: 

```json
{
	"userId": "{{user.external_id || user.id}}"
}
```

You can now access this value using the following:
```ts 
const { sessionClaims } = auth();
console.log(sessionClaims.userId) 
```

You can add the following for typescript: 
```js
// types/global.d.ts

export { };

declare global {
  interface CustomJwtSessionClaims {
    userId?: string;
  }
}
```

**Side note, we're currently patching the Clerk auth() function so that you can just set the userid as externalid instead of having to set external id, here's a patch to set the userid to externalId, once you can set userid on createUser, we can delete this and just reference userId**

We do this so that if you choose to store your user metadata in your own table, you can reference the information with just 1 key. You can export this from /src/app/_auth-migration/authPatch.ts.

```ts
/// src/app/_auth-migration/authPatch.ts 

import { auth as ogAuth } from "@clerk/nextjs/server";
// this function sets the userId to the sessionClaims userId which
// is the externalId but if exteranal id is not set, it will be
// the clerk user id
// this is used to only use one key for the user_metadata table in db calls
export function auth() {
  const ogAuthRes = ogAuth();
  ogAuthRes.userId = ogAuthRes.sessionClaims!.userId! as string;
  return ogAuthRes;
}

```

#### Here is an example of accessing the user metadata tenet tables with the new patterns (using the patched auth function)

```js
// src/app/page.tsx

import { auth, signOut } from "@/auth";
import {
  oldCheckHasSession,
} from "@/app/_auth-migration/sampleHelpers";
import { auth as authPatch } from "./authPatch";
import { db } from "@/server/neonDb";
import { userAttributes, users } from "@/server/neonDb/schema";
import { eq } from "drizzle-orm";

import { redirect } from "next/navigation";

export default async function Home() {
  const session = await oldCheckHasSession();
  const clerkUser = authPatch();
  if (session === null) {
    return redirect("/sign-in");
  }

  const userAttribute = await db.query.userAttributes.findFirst({
    where: eq(userAttributes.id, clerkUser.userId!),
  });

  return (
    <>
      <div>Signed In with Next-Auth</div>
      <div>{JSON.stringify(session)}</div>
      <div>Special Attribute: {userAttribute?.attribute}</div>
      <form
        action={async () => {
          "use server";
          await signOut();
        }}
      >
        <button type="submit">Sign Out</button>
      </form>
    </>
  );
}

```

#### We want users to edit their profile (attribute that are not classified as user metadata) in nextauth when they haven't been added to Clerk yet, but if they are in Clerk, we want them to edit profile information in Clerk, this allows them to change profile information during the migration process

```js
// src/app/changePassword/page.tsx

import { auth as nextAuthFunction } from "@/auth";
import { db } from "@/server/neonDb";
import {
  oldCheckHasSession,
} from "@/app/_auth-migration/sampleHelpers";
import { users } from "@/server/neonDb/schema";
import { auth } from "@clerk/nextjs/server";

import { UserButton } from "@clerk/nextjs";
import { redirect } from "next/navigation";

// checks if user is in Clerk, if in Clerk, change password in Clerk (semantic user button)
// if not in Clerk, change password in nextauth
export default async function Home() {
  const { userId }: { userId: string | null } = auth();
  const nexAuthUser = await oldCheckHasSession();

  if (userId === null && nexAuthUser === null) {
    return redirect("/sign-in");
  }

  // if the user hasn't been migrated to Clerk, change the password in nextauth
  if (userId === null) {
    return (
      <>
        <form
          action={async (formData) => {
            "use server";
            await db.update(users).set({
              password: formData.get("password") as string,
            });
          }}
        >
          <input type="password" name="password" />
          <button type="submit">Change Password</button>
        </form>
      </>
    );
  }

  // semantic representation of changing user profile in Clerk
  return (
    <>
      <UserButton />
    </>
  );
}
```

#### Here is an example of accessing the user metadata through Clerk's metadata

If you would like to store user metadata within Clerk's User object, here is how you do it.

```js
// wherever you call createUser

await clerkClient.users.createUser({
  firstName: "Test",
  lastName: "User",
  emailAddress: [ "testclerk123@gmail.com" ],
  password: "password",
  public_metadata: {role: "Engineer"},
  private_metadata: {skillIssue: "can't center div"},
  unsafe_metadata: {status: "happy"}
})
```

```js
// where you choose to access user object

import { currentUser } from '@clerk/nextjs/server';

export default async function Page() {
  const user = await currentUser();

  if (!user) return <div>Not signed in</div>;

  return <div>Role {user?.publicMetadata.role}</div>;
}
```

With all these in place, you can push to prod and start having users trickle over to clerk! 

### 7. Batch Import

The batch import handles the migration of the rest of the users that the trickle doesn't migrate through a scheduled process, ensuring all users are migrated without overwhelming the system and hitting the rate limit (20req/10sec). 

You should start the batch after the thundering herd is done thundering aka the trickle slows below a rate of 20req/10sec. You can fine tune the rate of the batch easily.

#### Script to get all users in existing database within a queue

Store all users in a queue for batch processing. This can be done using a standalone nodejs script. The implementation uses nextjs app router's server components and Upstash for the queue.

The process is just iterating through all the users, storing them in a queue for the cron job to process individually. Definitely scaling concerns but you can modify this solution to fit your scale.

If you are using oauth, you don't have to store a password.

```js
// src/app/_auth-migration/batch/page.tsx
import { db } from "@/server/neonDb";
import { Redis } from "@upstash/redis";

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL,
  token: process.env.UPSTASH_REDIS_REST_TOKEN,
});

export default function Batch() {
  async function buttonPress() {
    "use server";
    const users = await db.query.users.findMany();

    for (const user of users) {
      // this example just uses the minimum recommended information
      // feel free to add all the fields you need
      await redis.rpush("email", user.email);
      await redis.rpush("password", user.password ?? "null"); // "null" might be cursed 
      await redis.rpush("id", user.id);
    }
  }
  return (
    <>
      <form action={buttonPress}>
        <button>Press me</button>
      </form>
    </>
  );
}
```

#### Backend API for Batch Import to import users into Clerk

Use a cron job to process the queue and create users in Clerk, respecting rate limits. This implementation uses Upstash for the cron job running but you can use any job runner of your choice. Again, does not have to be in nextjs, can be any node backend.

You can tune the rate of batching by adjusting the for loop or adjusting the cron job calling interval. 

```js
// src/app/_auth-migration/batch/route.ts

import { db } from "@/server/neonDb";
import { userAttributes } from "@/server/neonDb/schema";
import { clerkClient } from "@clerk/nextjs/server";
import { Receiver } from "@upstash/qstash";
import { Redis } from "@upstash/redis";
import { eq } from "drizzle-orm";
import { headers } from "next/headers";

const receiver = new Receiver({
  currentSigningKey: process.env.QSTASH_CURRENT_SIGNING_KEY!,
  nextSigningKey: process.env.QSTASH_NEXT_SIGNING_KEY!,
});

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL,
  token: process.env.UPSTASH_REDIS_REST_TOKEN,
});

export async function POST() {
  const headersList = headers();
  const signature = headersList.get("Upstash-Signature");

  if (!signature) {
    return new Response("No signature", { status: 401 });
  }

  const isValid = await receiver.verify({
    body: "",
    signature,
    url: process.env.WEBHOOK_URL!,
  });

  if (!isValid) {
    return new Response("Invalid signature", { status: 401 });
  }

  // --- everything above this line is queue specific code to
  // authenticate the queue api ---

  const lengthOfQueue = await redis.llen("key");

  // you can modify how many requests you want your queue to pop here,
  // this is using the max, 20 requests, but you can tone it donwn to
  // work with the trickle if your trickle is going at the same time
  const lengthOfLoop = lengthOfQueue > 20 ? 20 : lengthOfQueue;

  for (let i = 0; i < lengthOfLoop; i++) {
    // pop off all the information we want
    const email = await redis.lpop<string | null>("email");
    const password = await redis.lpop<string | null>("password");
    const id = await redis.lpop<string>("id");
    if (!email) break;

    // check if user already exists
    const searchUser = await clerkClient.users.getUserList({
      emailAddress: [email],
    });

    // create user if they dont exist
    if (searchUser.data.length > 0) {
      continue;
    } else {
      await clerkClient.users.createUser({
        emailAddress: [email],
        password: password === "null" ? undefined : password!,
        externalId: id!,
        skipPasswordRequirement: true,
        skipPasswordChecks: true,
      });
    }
  }
  return new Response("OK", { status: 200 });
}

```

## After the migration ('after-migration' branch)

Once all users are batched into Clerk, we can switch the signups and sign ins to Clerk! Since we signed in those who are already using the app, it will be a seamless switch!

### 8. Sign-Ups and Sign-Ins go through the Clerk components

New user sign ups go through the Clerk components.

```js
// src/app/sign-up/[[...sign-up]]/page.tsx
import { SignUp } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";

import { redirect } from "next/navigation";

export default function SignUpComponent() {
  const { userId }: { userId: string | null } = auth();
  if (userId === null) {
    return (
      <>
        <SignUp forceRedirectUrl={"/"} />
      </>
    );
  }

  return redirect("/");
}

// src/app/sign-in/[[...sign-in]]/page.tsx
import { SignIn } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";

import { redirect } from "next/navigation";

export default function SignInComponent() {
  const { userId }: { userId: string | null } = auth();
  if (userId === null) {
    return (
      <>
        <SignIn forceRedirectUrl={"/"} />
      </>
    );
  }

  return redirect("/");
}
```

## Overview of migration flow

1. Add clerk middleware
2. Add <clerkProvider>
3. Clone the auth-migration folder
4. Add “auth-migration” route and export the post request from it
5. Wrap your app with <TrickleWrapper> from the “package”/file
6. Migrate auth helper functions to use clerk’s auth helpers instead of next auth

Ready to push to prod!

1. Batch import - this is for mass importing users from your entire users table to clerk, also does not have to start at the same time as the trickle to save bandwidth, we can wait for the thundering herd to be done and then start batch
    1. Put your entire user table into a queue
    2. A cron job calls /api/batch every 10 seconds which pops off 20 items of the queue, checks if they exist in clerk
        1. If not in clerk, Create user
        2. If in clerk, ignore’
2. Switch from clerk components
3. Remove trickle and batch code

In both trickle and batch, make sure to mention that for user metadata, there are 2 ways to store information, tenet (separate) table with a foreign key of either externalid/userid, or use clerk metadata
	- show how to do both
	- also show how im editing the userid to be user.sessionclaims.userid
	and why its bad dx

## Wrapping Up
With your users now imported into Clerk and your application updated, you can fully switch to using Clerk for authentication. This guide provides a comprehensive approach to migrating from Next-Auth to Clerk!